#!/usr/bin/env python3
"""
Monitor WhatsApp com Download Autom√°tico de M√≠dia
Monitora mensagens e processa automaticamente imagens, v√≠deos, documentos e √°udios
"""

import requests
import json
import time
import os
import base64
from datetime import datetime
from pathlib import Path


class MonitorMidiaWhatsApp:
    def __init__(self, webhook_id=None, instance_id=None, bearer_token=None):
        self.webhook_id = webhook_id
        self.instance_id = instance_id
        self.bearer_token = bearer_token
        self.mensagens_processadas = set()
        self.contador_mensagens = 0
        self.contador_midias = 0
        self.base_url = "https://api.w-api.app/v1"

        # Criar pasta para downloads
        self.pasta_downloads = Path("downloads_whatsapp")
        self.pasta_downloads.mkdir(exist_ok=True)

    def carregar_configuracao(self):
        """Carrega configura√ß√£o de vari√°veis de ambiente ou solicita"""

        # Tentar vari√°veis de ambiente primeiro
        self.webhook_id = self.webhook_id or os.getenv('WEBHOOK_ID', '0e6e92fd-c357-44e4-b1e5-067d6ae4cd0d')
        self.instance_id = self.instance_id or os.getenv('WAPI_INSTANCE_ID')
        self.bearer_token = self.bearer_token or os.getenv('WAPI_BEARER_TOKEN')

        # Se n√£o tem configura√ß√£o da API, solicitar
        if not self.instance_id or not self.bearer_token:
            print("üîß CONFIGURA√á√ÉO W-API (para download)")
            print("=" * 40)
            print("üí° Opcional: Para download autom√°tico de m√≠dia")
            print("üí° Deixe vazio para apenas monitorar")

            if not self.instance_id:
                self.instance_id = input("üì± Instance ID (opcional): ").strip()

            if not self.bearer_token:
                self.bearer_token = input("üîë Bearer Token (opcional): ").strip()

        return True

    def eh_mensagem_whatsapp(self, data):
        """Verifica se √© uma mensagem v√°lida do WhatsApp"""
        if isinstance(data, dict):
            return any([
                data.get('event') == 'webhookDelivery',
                data.get('event') == 'webhookReceived',
                data.get('event') == 'message',
                'instanceId' in data,
                'msgContent' in data,
                'sender' in data and 'chat' in data
            ])
        return False

    def extrair_informacoes_midia(self, msg_content):
        """Extrai informa√ß√µes de m√≠dia para download"""

        midias_info = []

        # Verificar diferentes tipos de m√≠dia
        tipos_midia = {
            'imageMessage': 'image',
            'videoMessage': 'video',
            'audioMessage': 'audio',
            'documentMessage': 'document',
            'stickerMessage': 'sticker'
        }

        for tipo_msg, tipo_midia in tipos_midia.items():
            if tipo_msg in msg_content:
                midia_data = msg_content[tipo_msg]

                info_midia = {
                    'type': tipo_midia,
                    'mediaKey': midia_data.get('mediaKey'),
                    'directPath': midia_data.get('directPath'),
                    'mimetype': midia_data.get('mimetype'),
                    'url': midia_data.get('url'),
                    'fileLength': midia_data.get('fileLength'),
                    'fileName': midia_data.get('fileName'),
                    'caption': midia_data.get('caption', ''),
                    'fileSha256': midia_data.get('fileSha256'),
                    'fileEncSha256': midia_data.get('fileEncSha256'),
                    'jpegThumbnail': midia_data.get('jpegThumbnail')
                }

                # Adicionar informa√ß√µes espec√≠ficas do tipo
                if tipo_midia == 'image':
                    info_midia.update({
                        'width': midia_data.get('width'),
                        'height': midia_data.get('height')
                    })
                elif tipo_midia == 'video':
                    info_midia.update({
                        'width': midia_data.get('width'),
                        'height': midia_data.get('height'),
                        'seconds': midia_data.get('seconds')
                    })
                elif tipo_midia == 'audio':
                    info_midia.update({
                        'seconds': midia_data.get('seconds'),
                        'ptt': midia_data.get('ptt', False)  # Push to talk
                    })
                elif tipo_midia == 'document':
                    info_midia.update({
                        'title': midia_data.get('title'),
                        'pageCount': midia_data.get('pageCount')
                    })

                midias_info.append(info_midia)

        return midias_info

    def baixar_midia(self, info_midia, message_id, sender_name):
        """Baixa m√≠dia usando a API W-API"""

        if not self.instance_id or not self.bearer_token:
            print("‚ö†Ô∏è API n√£o configurada - n√£o √© poss√≠vel baixar m√≠dia")
            return None

        if not info_midia.get('mediaKey') or not info_midia.get('directPath'):
            print("‚ùå Informa√ß√µes de m√≠dia incompletas")
            return None

        url = f"{self.base_url}/media/download"
        headers = {
            'Content-Type': 'application/json',
            'Authorization': f'Bearer {self.bearer_token}'
        }
        params = {
            'instanceId': self.instance_id
        }

        payload = {
            'mediaKey': info_midia['mediaKey'],
            'directPath': info_midia['directPath'],
            'type': info_midia['type'],
            'mimetype': info_midia['mimetype']
        }

        try:
            print(f"üì• Baixando {info_midia['type']}...")
            response = requests.post(url, headers=headers, params=params, json=payload, timeout=30)

            if response.status_code == 200:
                result = response.json()

                if not result.get('error', True):
                    media_data = result.get('data', {})
                    media_base64 = media_data.get('media')

                    if media_base64:
                        # Decodificar base64
                        media_bytes = base64.b64decode(media_base64)

                        # Gerar nome do arquivo
                        extensao = self.obter_extensao_mimetype(info_midia['mimetype'])
                        nome_arquivo = self.gerar_nome_arquivo(
                            info_midia, message_id, sender_name, extensao
                        )

                        # Salvar arquivo
                        caminho_arquivo = self.pasta_downloads / nome_arquivo
                        with open(caminho_arquivo, 'wb') as f:
                            f.write(media_bytes)

                        print(f"‚úÖ M√≠dia salva: {caminho_arquivo}")
                        return str(caminho_arquivo)
                    else:
                        print("‚ùå Dados de m√≠dia n√£o encontrados na resposta")
                        return None
                else:
                    print(f"‚ùå Erro na API: {result.get('message', 'Erro desconhecido')}")
                    return None
            else:
                print(f"‚ùå Erro HTTP: {response.status_code}")
                return None

        except Exception as e:
            print(f"‚ùå Erro ao baixar m√≠dia: {e}")
            return None

    def obter_extensao_mimetype(self, mimetype):
        """Obt√©m extens√£o baseada no mimetype"""

        mimetypes_map = {
            'image/jpeg': '.jpg',
            'image/png': '.png',
            'image/gif': '.gif',
            'image/webp': '.webp',
            'video/mp4': '.mp4',
            'video/avi': '.avi',
            'video/mov': '.mov',
            'audio/mpeg': '.mp3',
            'audio/ogg': '.ogg',
            'audio/wav': '.wav',
            'audio/mp4': '.m4a',
            'application/pdf': '.pdf',
            'application/msword': '.doc',
            'application/vnd.openxmlformats-officedocument.wordprocessingml.document': '.docx',
            'text/plain': '.txt'
        }

        return mimetypes_map.get(mimetype, '.bin')

    def gerar_nome_arquivo(self, info_midia, message_id, sender_name, extensao):
        """Gera nome √∫nico para o arquivo"""

        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")

        # Limpar nome do remetente
        sender_clean = "".join(c for c in sender_name if c.isalnum() or c in (' ', '-', '_')).strip()
        sender_clean = sender_clean.replace(' ', '_')

        # Se tem nome de arquivo original, usar
        if info_midia.get('fileName'):
            nome_original = info_midia['fileName']
            nome_sem_ext = os.path.splitext(nome_original)[0]
            return f"{timestamp}_{sender_clean}_{nome_sem_ext}{extensao}"

        # Sen√£o, usar tipo e ID da mensagem
        tipo = info_midia['type']
        message_short = message_id[:8] if message_id else "unknown"

        return f"{timestamp}_{sender_clean}_{tipo}_{message_short}{extensao}"

    def processar_mensagem_whatsapp(self, data):
        """Processa mensagem e extrai/baixa m√≠dias"""

        self.contador_mensagens += 1

        print('\n' + 'üü¢' * 70)
        print(f'üì± MENSAGEM #{self.contador_mensagens} - {datetime.now().strftime("%H:%M:%S")}')
        print('üü¢' * 70)

        # Informa√ß√µes b√°sicas
        instance_id = data.get('instanceId', 'N/A')
        phone = data.get('connectedPhone', 'N/A')
        is_group = data.get('isGroup', False)
        from_me = data.get('fromMe', False)
        message_id = data.get('messageId', 'N/A')

        print(f"üìû Inst√¢ncia: {instance_id}")
        print(f"üì± Telefone: {phone}")
        print(f"üÜî Message ID: {message_id}")
        print(f"{'üë• GRUPO' if is_group else 'üë§ PRIVADO'} | {'üì§ ENVIADA' if from_me else 'üì• RECEBIDA'}")

        # Informa√ß√µes do remetente
        sender = data.get('sender', {})
        sender_name = sender.get('pushName', 'Sem nome')
        sender_id = sender.get('id', 'N/A')

        print(f"\nüë§ DE: {sender_name}")
        print(f"üìû ID: {sender_id}")

        # Informa√ß√µes do chat
        chat = data.get('chat', {})
        chat_id = chat.get('id', 'N/A')
        print(f"üí≠ Chat ID: {chat_id}")

        # Processar conte√∫do da mensagem
        msg_content = data.get('msgContent', {})

        if msg_content:
            # Verificar se h√° texto
            if 'conversation' in msg_content:
                print(f"\nüí¨ MENSAGEM:")
                print(f"üìù {msg_content['conversation']}")

            # Extrair informa√ß√µes de m√≠dia
            midias_info = self.extrair_informacoes_midia(msg_content)

            if midias_info:
                print(f"\nüìé M√çDIA DETECTADA ({len(midias_info)} arquivo(s)):")

                for i, info_midia in enumerate(midias_info, 1):
                    self.contador_midias += 1

                    print(f"\nüìÑ Arquivo #{i}:")
                    print(f"   üéØ Tipo: {info_midia['type']}")
                    print(f"   üìã Mimetype: {info_midia['mimetype']}")

                    if info_midia.get('fileName'):
                        print(f"   üìÅ Nome: {info_midia['fileName']}")

                    if info_midia.get('fileLength'):
                        size_mb = int(info_midia['fileLength']) / (1024 * 1024)
                        print(f"   üìè Tamanho: {size_mb:.2f} MB")

                    if info_midia.get('caption'):
                        print(f"   üìù Legenda: {info_midia['caption']}")

                    # Informa√ß√µes espec√≠ficas do tipo
                    if info_midia['type'] in ['image', 'video']:
                        width = info_midia.get('width')
                        height = info_midia.get('height')
                        if width and height:
                            print(f"   üìê Dimens√µes: {width}x{height}")

                    if info_midia['type'] in ['video', 'audio']:
                        seconds = info_midia.get('seconds')
                        if seconds:
                            print(f"   ‚è±Ô∏è Dura√ß√£o: {seconds}s")

                    # Exibir informa√ß√µes para download manual
                    print(f"\n   üîß DADOS PARA DOWNLOAD:")
                    print(f"   mediaKey: {info_midia.get('mediaKey', 'N/A')}")
                    print(f"   directPath: {info_midia.get('directPath', 'N/A')}")
                    print(f"   type: {info_midia['type']}")
                    print(f"   mimetype: {info_midia['mimetype']}")

                    # Tentar baixar automaticamente
                    if self.instance_id and self.bearer_token:
                        caminho_arquivo = self.baixar_midia(info_midia, message_id, sender_name)
                        if caminho_arquivo:
                            print(f"   ‚úÖ Baixado: {caminho_arquivo}")
                    else:
                        print(f"   üí° Configure API para download autom√°tico")

        # Timestamp
        moment = data.get('moment')
        if moment:
            dt = datetime.fromtimestamp(moment)
            print(f"\nüïê Enviada em: {dt.strftime('%d/%m/%Y √†s %H:%M:%S')}")

        print('üü¢' * 70 + '\n')

    def buscar_mensagens_novas(self):
        """Busca mensagens novas no webhook"""
        try:
            url = f"https://webhook.site/token/{self.webhook_id}/requests"
            response = requests.get(url, timeout=10)

            if response.status_code == 200:
                data = response.json()
                requests_data = data.get('data', [])

                mensagens_novas = []

                for request in requests_data:
                    request_id = request.get('uuid')

                    if request_id and request_id not in self.mensagens_processadas:
                        content = request.get('content')

                        if content and isinstance(content, str):
                            try:
                                message_data = json.loads(content)

                                if self.eh_mensagem_whatsapp(message_data):
                                    mensagens_novas.append({
                                        'id': request_id,
                                        'data': message_data
                                    })
                                    self.mensagens_processadas.add(request_id)

                            except json.JSONDecodeError:
                                pass

                return mensagens_novas

            elif response.status_code == 404:
                print("‚ùå Webhook n√£o encontrado ou expirado!")
                return None
            else:
                return []

        except Exception as e:
            print(f"‚ö†Ô∏è Erro ao buscar mensagens: {e}")
            return []

    def monitorar_com_midia(self):
        """Monitora mensagens e processa m√≠dias"""

        print(f"\nüöÄ MONITOR COM PROCESSAMENTO DE M√çDIA")
        print("=" * 50)
        print(f"üîó Webhook: {self.webhook_id}")
        print(f"üìÅ Downloads: {self.pasta_downloads}")

        if self.instance_id and self.bearer_token:
            print(f"üì± Instance: {self.instance_id}")
            print("‚úÖ Download autom√°tico ATIVO")
        else:
            print("‚ö†Ô∏è Download manual (dados ser√£o exibidos)")

        print("üí° Pressione Ctrl+C para parar")
        print("üîÑ Verificando a cada 3 segundos...\n")

        inicio = datetime.now()

        try:
            while True:
                mensagens_novas = self.buscar_mensagens_novas()

                if mensagens_novas is None:
                    break

                if mensagens_novas:
                    for msg in mensagens_novas:
                        self.processar_mensagem_whatsapp(msg['data'])

                # Status a cada 60 segundos
                tempo_ativo = datetime.now() - inicio
                if tempo_ativo.seconds % 60 == 0 and tempo_ativo.seconds > 0:
                    print(
                        f"‚è±Ô∏è Ativo h√° {tempo_ativo.seconds // 60}min | Mensagens: {self.contador_mensagens} | M√≠dias: {self.contador_midias}")

                time.sleep(3)

        except KeyboardInterrupt:
            tempo_total = datetime.now() - inicio
            print(f"\nüëã MONITORAMENTO PARADO!")
            print(f"üìä Mensagens processadas: {self.contador_mensagens}")
            print(f"üìé M√≠dias encontradas: {self.contador_midias}")
            print(f"‚è±Ô∏è Tempo ativo: {tempo_total.seconds // 60}min {tempo_total.seconds % 60}s")
            print(f"üìÅ Downloads salvos em: {self.pasta_downloads}")

    def executar(self):
        """Executa o monitor"""

        print("üìé MONITOR WHATSAPP COM M√çDIA")
        print("=" * 40)
        print("üéØ Detecta e processa imagens, v√≠deos, √°udios e documentos")

        if self.carregar_configuracao():
            print(f"\n‚úÖ Webhook: {self.webhook_id}")

            if self.instance_id and self.bearer_token:
                print("üîß API configurada - download autom√°tico ATIVO")
            else:
                print("üí° API n√£o configurada - apenas exibi√ß√£o de dados")

            self.monitorar_com_midia()


def main():
    """Fun√ß√£o principal"""
    monitor = MonitorMidiaWhatsApp()
    monitor.executar()


if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        print("\nüëã Monitor encerrado!")
    except Exception as e:
        print(f"\n‚ùå Erro: {e}")

# ========================================
# CONFIGURA√á√ÉO VIA VARI√ÅVEIS DE AMBIENTE:
# ========================================
#
# export WEBHOOK_ID=seu_webhook_id
# export WAPI_INSTANCE_ID=sua_instancia  
# export WAPI_BEARER_TOKEN=seu_token
# python monitor_midia.py
#
# ========================================